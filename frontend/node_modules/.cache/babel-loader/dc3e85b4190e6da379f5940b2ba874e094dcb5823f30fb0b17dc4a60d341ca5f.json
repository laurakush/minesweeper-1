{"ast":null,"code":"import { Game, Mine } from './gameDomain';\n\n// Constants\nconst MINE = -1;\n\n// Direction arrays for traversing neighboring cells (8 directions)\nconst dx = [-1, 0, 1, -1, 1, -1, 0, 1];\nconst dy = [-1, -1, -1, 0, 0, 1, 1, 1];\n\n// ==============================\n// Utility Functions\n// ==============================\n\n// Checks if a cell contains a mine\nfunction isMine(mine) {\n  return mine.bombs === MINE;\n}\n\n// Creates a deep copy of the game board\nfunction createDeepCopy(state) {\n  return state.map(row => row.map(cell => new Mine({\n    x: cell.pos.x,\n    y: cell.pos.y\n  }, cell.bombs, cell.isFlagged, cell.isOpened)));\n}\n\n// Performs an operation on all neighboring cells of a given cell\nfunction traverseNeighbors(board, mine, callback) {\n  const {\n    x,\n    y\n  } = mine.pos;\n  for (let i = 0; i < dx.length; i++) {\n    const newX = x + dx[i];\n    const newY = y + dy[i];\n\n    // Check if coordinates are within bounds\n    if (newX >= 0 && newX < board.length && newY >= 0 && newY < board[0].length) {\n      callback(board[newX][newY]);\n    }\n  }\n}\n\n// ==============================\n// Board Generation Functions\n// ==============================\n\n// Creates an empty board with no mines\nfunction createEmptyBoard(rows, cols) {\n  const board = [];\n\n  // Initialize a board with no mines\n  for (let i = 0; i < rows; i++) {\n    const row = [];\n    for (let j = 0; j < cols; j++) {\n      row.push(new Mine({\n        x: i,\n        y: j\n      }, 0, false, false));\n    }\n    board.push(row);\n  }\n  return board;\n}\n\n// Places mines on the board after the first click\nfunction placeMines(board, firstClickPos, totalMines) {\n  const rows = board.length;\n  const cols = board[0].length;\n\n  // Set of positions to avoid (first click and its neighbors)\n  const safePositions = new Set();\n\n  // Add first click position to safe set\n  safePositions.add(`${firstClickPos.x},${firstClickPos.y}`);\n\n  // Add neighboring positions to safe set\n  traverseNeighbors(board, board[firstClickPos.x][firstClickPos.y], neighbor => {\n    safePositions.add(`${neighbor.pos.x},${neighbor.pos.y}`);\n  });\n\n  // Place mines randomly on the board, avoiding safe positions\n  let minesPlaced = 0;\n  while (minesPlaced < totalMines) {\n    const x = Math.floor(Math.random() * rows);\n    const y = Math.floor(Math.random() * cols);\n    const posKey = `${x},${y}`;\n\n    // Check if position is safe and doesn't already have a mine\n    if (!safePositions.has(posKey) && !isMine(board[x][y])) {\n      board[x][y].bombs = MINE;\n      minesPlaced++;\n    }\n  }\n\n  // Calculate numbers for each cell\n  fillBombsCount(board);\n}\n\n// Calculates the number of adjacent mines for each cell\nfunction fillBombsCount(board) {\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      const cell = board[i][j];\n\n      // Skip mines\n      if (isMine(cell)) continue;\n\n      // Count mines in neighboring cells\n      let count = 0;\n      traverseNeighbors(board, cell, neighbor => {\n        if (isMine(neighbor)) {\n          count++;\n        }\n      });\n      cell.bombs = count;\n    }\n  }\n}\n\n// Creates a new empty game (no mines placed yet)\nfunction newGame(rows, cols, mines) {\n  const board = createEmptyBoard(rows, cols);\n  return new Game(board, false, mines, 0, 0, false);\n}\n\n// ==============================\n// Game Status Check\n// ==============================\n\n// Check if the game is completed (win condition)\nfunction checkGameStatus(game) {\n  // If already over (lost), don't change anything\n  if (game.isOver && !game.isWon) return game;\n\n  // Calculate win condition - all non-mine cells are opened\n  const totalCells = game.state.length * game.state[0].length;\n  const nonMineCells = totalCells - game.totBombs;\n  const isWon = game.openedCells === nonMineCells;\n\n  // Return updated game with win state if won\n  if (isWon) {\n    return new Game(game.state, true,\n    // Game is over\n    game.totBombs, game.openedCells, game.flaggedCells, true // Game is won\n    );\n  }\n  return game;\n}\n\n// ==============================\n// Game Action Functions\n// ==============================\n\n// Handles the first click in a game\nfunction handleFirstClick(game, field) {\n  // Create a deep copy of the board\n  const newState = createDeepCopy(game.state);\n\n  // Place mines, avoiding first click and its neighbors\n  placeMines(newState, field.pos, game.totBombs);\n\n  // Open the clicked cell and surrounding cells if it's a 0\n  const clickedCell = newState[field.pos.x][field.pos.y];\n  clickedCell.isOpened = true;\n  let openedCount = 1; // Count the clicked cell\n\n  if (clickedCell.bombs === 0) {\n    openedCount += openEmptyCells(newState, clickedCell);\n  }\n\n  // Create updated game state\n  const updatedGame = new Game(newState, false, game.totBombs, openedCount, game.flaggedCells, false);\n\n  // Check if this move won the game\n  return checkGameStatus(updatedGame);\n}\n\n// Opens a cell on the board\nfunction openCell(game, field) {\n  // Skip if game is already over, or cell is already opened or flagged\n  if (game.isOver || field.isFlagged || field.isOpened) return game;\n\n  // Check if this is the first click\n  const isFirstClick = game.openedCells === 0 && !game.state.some(row => row.some(cell => isMine(cell)));\n\n  // Handle first click specially\n  if (isFirstClick) {\n    return handleFirstClick(game, field);\n  }\n\n  // Regular click handling for subsequent clicks\n  const newState = createDeepCopy(game.state);\n  const clickedCell = newState[field.pos.x][field.pos.y];\n\n  // If mine, game over with loss\n  if (isMine(clickedCell)) {\n    revealAllMines(newState);\n    return new Game(newState, true,\n    // Game is over\n    game.totBombs, game.openedCells, game.flaggedCells, false // Game is lost\n    );\n  }\n\n  // Open the cell and increment counter\n  clickedCell.isOpened = true;\n  let newOpenedCount = game.openedCells + 1;\n\n  // If empty, open surrounding cells\n  if (clickedCell.bombs === 0) {\n    const additionalCellsOpened = openEmptyCells(newState, clickedCell);\n    newOpenedCount += additionalCellsOpened;\n  }\n\n  // Create updated game state\n  const updatedGame = new Game(newState, false, game.totBombs, newOpenedCount, game.flaggedCells, false);\n\n  // Check if this move won the game\n  return checkGameStatus(updatedGame);\n}\n\n// Recursively opens empty cells\nfunction openEmptyCells(board, startCell) {\n  const visited = new Set();\n  const queue = [startCell];\n  let cellsOpened = 0;\n  while (queue.length > 0) {\n    const cell = queue.shift();\n    const key = `${cell.pos.x},${cell.pos.y}`;\n    if (visited.has(key)) continue;\n    visited.add(key);\n    if (!cell.isOpened) {\n      cell.isOpened = true;\n      cellsOpened++;\n    }\n\n    // If cell has no adjacent mines, explore neighbors\n    if (cell.bombs === 0) {\n      traverseNeighbors(board, cell, neighbor => {\n        if (!neighbor.isOpened && !neighbor.isFlagged && !isMine(neighbor)) {\n          queue.push(neighbor);\n        }\n      });\n    }\n  }\n  return cellsOpened;\n}\n\n// Toggles a flag on a cell\nfunction toggleFlag(game, field) {\n  // Skip if game is over or cell is already opened\n  if (game.isOver || field.isOpened) return game;\n  const newState = createDeepCopy(game.state);\n  const cell = newState[field.pos.x][field.pos.y];\n\n  // Toggle flag and update counter\n  cell.isFlagged = !cell.isFlagged;\n  const newFlaggedCount = cell.isFlagged ? game.flaggedCells + 1 : game.flaggedCells - 1;\n\n  // Create updated game state\n  return new Game(newState, game.isOver, game.totBombs, game.openedCells, newFlaggedCount, game.isWon);\n}\n\n// ==============================\n// Game State Functions\n// ==============================\n\n// Counts the number of flagged cells\nfunction countFlagged(game) {\n  return game.flaggedCells;\n}\n\n// Reveals all mines on the board (used when game is over)\nfunction revealAllMines(board) {\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      if (isMine(board[i][j])) {\n        board[i][j].isOpened = true;\n      }\n    }\n  }\n}\n\n// ==============================\n// Public API\n// ==============================\n\nexport const game = {\n  newGame,\n  fillBombsCount,\n  countFlagged,\n  isCompleted: game => game.isOver && game.isWon,\n  // Simplified completion check\n  markMine: toggleFlag,\n  openMine: openCell\n};","map":{"version":3,"names":["Game","Mine","MINE","dx","dy","isMine","mine","bombs","createDeepCopy","state","map","row","cell","x","pos","y","isFlagged","isOpened","traverseNeighbors","board","callback","i","length","newX","newY","createEmptyBoard","rows","cols","j","push","placeMines","firstClickPos","totalMines","safePositions","Set","add","neighbor","minesPlaced","Math","floor","random","posKey","has","fillBombsCount","count","newGame","mines","checkGameStatus","game","isOver","isWon","totalCells","nonMineCells","totBombs","openedCells","flaggedCells","handleFirstClick","field","newState","clickedCell","openedCount","openEmptyCells","updatedGame","openCell","isFirstClick","some","revealAllMines","newOpenedCount","additionalCellsOpened","startCell","visited","queue","cellsOpened","shift","key","toggleFlag","newFlaggedCount","countFlagged","isCompleted","markMine","openMine"],"sources":["/Users/laurakushnir/Documents/Minesweeper-TS/minesweeper-1/src/gameLogic/game.ts"],"sourcesContent":["import { Game, Mine, Point } from './gameDomain';\n\n// Constants\nconst MINE = -1;\n\n// Direction arrays for traversing neighboring cells (8 directions)\nconst dx = [-1, 0, 1, -1, 1, -1, 0, 1];\nconst dy = [-1, -1, -1, 0, 0, 1, 1, 1];\n\n// ==============================\n// Utility Functions\n// ==============================\n\n// Checks if a cell contains a mine\nfunction isMine(mine: Mine): boolean {\n    return mine.bombs === MINE;\n}\n\n// Creates a deep copy of the game board\nfunction createDeepCopy(state: Array<Array<Mine>>): Array<Array<Mine>> {\n    return state.map(row => \n        row.map(cell => \n            new Mine(\n                { x: cell.pos.x, y: cell.pos.y },\n                cell.bombs,\n                cell.isFlagged,\n                cell.isOpened\n            )\n        )\n    );\n}\n\n// Performs an operation on all neighboring cells of a given cell\nfunction traverseNeighbors(board: Mine[][], mine: Mine, callback: (field: Mine) => void): void {\n    const { x, y } = mine.pos;\n    \n    for (let i = 0; i < dx.length; i++) {\n        const newX = x + dx[i];\n        const newY = y + dy[i];\n        \n        // Check if coordinates are within bounds\n        if (newX >= 0 && newX < board.length && newY >= 0 && newY < board[0].length) {\n            callback(board[newX][newY]);\n        }\n    }\n}\n\n// ==============================\n// Board Generation Functions\n// ==============================\n\n// Creates an empty board with no mines\nfunction createEmptyBoard(rows: number, cols: number): Array<Array<Mine>> {\n    const board: Mine[][] = [];\n\n    // Initialize a board with no mines\n    for(let i = 0; i < rows; i++){\n        const row: Mine[] = [];\n        for(let j = 0; j < cols; j++){\n            row.push(new Mine({x: i, y: j}, 0, false, false));\n        }\n        board.push(row);\n    }\n    \n    return board;\n}\n\n// Places mines on the board after the first click\nfunction placeMines(board: Array<Array<Mine>>, firstClickPos: Point, totalMines: number): void {\n    const rows = board.length;\n    const cols = board[0].length;\n    \n    // Set of positions to avoid (first click and its neighbors)\n    const safePositions = new Set<string>();\n    \n    // Add first click position to safe set\n    safePositions.add(`${firstClickPos.x},${firstClickPos.y}`);\n    \n    // Add neighboring positions to safe set\n    traverseNeighbors(board, board[firstClickPos.x][firstClickPos.y], (neighbor) => {\n        safePositions.add(`${neighbor.pos.x},${neighbor.pos.y}`);\n    });\n    \n    // Place mines randomly on the board, avoiding safe positions\n    let minesPlaced = 0;\n    while (minesPlaced < totalMines) {\n        const x = Math.floor(Math.random() * rows);\n        const y = Math.floor(Math.random() * cols);\n        const posKey = `${x},${y}`;\n\n        // Check if position is safe and doesn't already have a mine\n        if (!safePositions.has(posKey) && !isMine(board[x][y])) {\n            board[x][y].bombs = MINE;\n            minesPlaced++;\n        }\n    }\n    \n    // Calculate numbers for each cell\n    fillBombsCount(board);\n}\n\n// Calculates the number of adjacent mines for each cell\nfunction fillBombsCount(board: Array<Array<Mine>>): void {\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            const cell = board[i][j];\n            \n            // Skip mines\n            if (isMine(cell)) continue;\n            \n            // Count mines in neighboring cells\n            let count = 0;\n            traverseNeighbors(board, cell, (neighbor) => {\n                if (isMine(neighbor)) {\n                    count++;\n                }\n            });\n            \n            cell.bombs = count;\n        }\n    }\n}\n\n// Creates a new empty game (no mines placed yet)\nfunction newGame(rows: number, cols: number, mines: number): Game {\n    const board = createEmptyBoard(rows, cols);\n    return new Game(board, false, mines, 0, 0, false);\n}\n\n// ==============================\n// Game Status Check\n// ==============================\n\n// Check if the game is completed (win condition)\nfunction checkGameStatus(game: Game): Game {\n    // If already over (lost), don't change anything\n    if (game.isOver && !game.isWon) return game;\n    \n    // Calculate win condition - all non-mine cells are opened\n    const totalCells = game.state.length * game.state[0].length;\n    const nonMineCells = totalCells - game.totBombs;\n    const isWon = game.openedCells === nonMineCells;\n    \n    // Return updated game with win state if won\n    if (isWon) {\n        return new Game(\n            game.state, \n            true,           // Game is over\n            game.totBombs, \n            game.openedCells, \n            game.flaggedCells,\n            true            // Game is won\n        );\n    }\n    \n    return game;\n}\n\n// ==============================\n// Game Action Functions\n// ==============================\n\n// Handles the first click in a game\nfunction handleFirstClick(game: Game, field: Mine): Game {\n    // Create a deep copy of the board\n    const newState = createDeepCopy(game.state);\n    \n    // Place mines, avoiding first click and its neighbors\n    placeMines(newState, field.pos, game.totBombs);\n    \n    // Open the clicked cell and surrounding cells if it's a 0\n    const clickedCell = newState[field.pos.x][field.pos.y];\n    clickedCell.isOpened = true;\n    let openedCount = 1; // Count the clicked cell\n    \n    if (clickedCell.bombs === 0) {\n        openedCount += openEmptyCells(newState, clickedCell);\n    }\n    \n    // Create updated game state\n    const updatedGame = new Game(\n        newState, \n        false, \n        game.totBombs, \n        openedCount, \n        game.flaggedCells,\n        false\n    );\n    \n    // Check if this move won the game\n    return checkGameStatus(updatedGame);\n}\n\n// Opens a cell on the board\nfunction openCell(game: Game, field: Mine): Game {\n    // Skip if game is already over, or cell is already opened or flagged\n    if (game.isOver || field.isFlagged || field.isOpened) return game;\n    \n    // Check if this is the first click\n    const isFirstClick = game.openedCells === 0 && !game.state.some(row => \n        row.some(cell => isMine(cell))\n    );\n    \n    // Handle first click specially\n    if (isFirstClick) {\n        return handleFirstClick(game, field);\n    }\n    \n    // Regular click handling for subsequent clicks\n    const newState = createDeepCopy(game.state);\n    const clickedCell = newState[field.pos.x][field.pos.y];\n    \n    // If mine, game over with loss\n    if (isMine(clickedCell)) {\n        revealAllMines(newState);\n        return new Game(\n            newState, \n            true,           // Game is over\n            game.totBombs, \n            game.openedCells, \n            game.flaggedCells,\n            false           // Game is lost\n        );\n    }\n    \n    // Open the cell and increment counter\n    clickedCell.isOpened = true;\n    let newOpenedCount = game.openedCells + 1;\n    \n    // If empty, open surrounding cells\n    if (clickedCell.bombs === 0) {\n        const additionalCellsOpened = openEmptyCells(newState, clickedCell);\n        newOpenedCount += additionalCellsOpened;\n    }\n    \n    // Create updated game state\n    const updatedGame = new Game(\n        newState, \n        false, \n        game.totBombs, \n        newOpenedCount, \n        game.flaggedCells,\n        false\n    );\n    \n    // Check if this move won the game\n    return checkGameStatus(updatedGame);\n}\n\n// Recursively opens empty cells\nfunction openEmptyCells(board: Array<Array<Mine>>, startCell: Mine): number {\n    const visited = new Set<string>();\n    const queue: Mine[] = [startCell];\n    let cellsOpened = 0;\n    \n    while (queue.length > 0) {\n        const cell = queue.shift()!;\n        const key = `${cell.pos.x},${cell.pos.y}`;\n        \n        if (visited.has(key)) continue;\n        visited.add(key);\n        \n        if (!cell.isOpened) {\n            cell.isOpened = true;\n            cellsOpened++;\n        }\n        \n        // If cell has no adjacent mines, explore neighbors\n        if (cell.bombs === 0) {\n            traverseNeighbors(board, cell, (neighbor) => {\n                if (!neighbor.isOpened && !neighbor.isFlagged && !isMine(neighbor)) {\n                    queue.push(neighbor);\n                }\n            });\n        }\n    }\n    \n    return cellsOpened;\n}\n\n// Toggles a flag on a cell\nfunction toggleFlag(game: Game, field: Mine): Game {\n    // Skip if game is over or cell is already opened\n    if (game.isOver || field.isOpened) return game;\n    \n    const newState = createDeepCopy(game.state);\n    const cell = newState[field.pos.x][field.pos.y];\n    \n    // Toggle flag and update counter\n    cell.isFlagged = !cell.isFlagged;\n    const newFlaggedCount = cell.isFlagged ? \n        game.flaggedCells + 1 : \n        game.flaggedCells - 1;\n    \n    // Create updated game state\n    return new Game(\n        newState, \n        game.isOver, \n        game.totBombs, \n        game.openedCells, \n        newFlaggedCount,\n        game.isWon\n    );\n}\n\n// ==============================\n// Game State Functions\n// ==============================\n\n// Counts the number of flagged cells\nfunction countFlagged(game: Game): number {\n    return game.flaggedCells;\n}\n\n// Reveals all mines on the board (used when game is over)\nfunction revealAllMines(board: Array<Array<Mine>>): void {\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (isMine(board[i][j])) {\n                board[i][j].isOpened = true;\n            }\n        }\n    }\n}\n\n// ==============================\n// Public API\n// ==============================\n\nexport const game = {\n    newGame,\n    fillBombsCount,\n    countFlagged,\n    isCompleted: (game: Game) => game.isOver && game.isWon, // Simplified completion check\n    markMine: toggleFlag,\n    openMine: openCell\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}