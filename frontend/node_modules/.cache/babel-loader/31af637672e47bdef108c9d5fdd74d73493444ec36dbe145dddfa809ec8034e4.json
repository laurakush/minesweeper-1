{"ast":null,"code":"import { Game, Mine } from './gameDomain';\nconst MINE = -1;\nconst dx = [-1, 0, 1, -1, 1, -1, 0, 1];\nconst dy = [-1, -1, -1, 0, 0, 1, 1, 1];\n\n// Track if this is the first click of the game\nlet isFirstClick = true;\n\n// Helper functions\nfunction isMine(mine) {\n  return mine.bombs === MINE;\n}\nfunction traverseNeighbors(board, mine, callback) {\n  const {\n    x,\n    y\n  } = mine.pos;\n  for (let i = 0; i < dx.length; i++) {\n    const newX = x + dx[i];\n    const newY = y + dy[i];\n\n    // Check if coordinates are within bounds\n    if (newX >= 0 && newX < board.length && newY >= 0 && newY < board[0].length) {\n      callback(board[newX][newY]);\n    }\n  }\n}\nfunction fillBoard(rows, cols, mines, safePos) {\n  const board = [];\n\n  // Initialize a board with no mines\n  for (let i = 0; i < rows; i++) {\n    const row = [];\n    for (let j = 0; j < cols; j++) {\n      row.push(new Mine({\n        x: i,\n        y: j\n      }, 0, false, false));\n    }\n    board.push(row);\n  }\n\n  // Place mines randomly on the board\n  let minesPlaced = 0;\n  while (minesPlaced < mines) {\n    let x = Math.floor(Math.random() * rows);\n    let y = Math.floor(Math.random() * cols);\n\n    // Skip if mine is already placed at this position\n    if (isMine(board[x][y])) {\n      continue;\n    }\n\n    // Skip if this is within the safe area around the first click\n    if (safePos && Math.abs(x - safePos.x) <= 1 && Math.abs(y - safePos.y) <= 1) {\n      continue;\n    }\n    board[x][y].bombs = MINE;\n    minesPlaced++;\n  }\n\n  // Calculate numbers for each cell\n  fillBombsCount(board);\n  return board;\n}\nfunction newGame(rows, cols, mines) {\n  // Reset first click tracking for a new game\n  isFirstClick = true;\n  const board = fillBoard(rows, cols, mines);\n  return new Game(board, false, mines);\n}\nfunction fillBombsCount(board) {\n  // First, reset all non-mine cells to zero\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      if (!isMine(board[i][j])) {\n        board[i][j].bombs = 0;\n      }\n    }\n  }\n\n  // Then count adjacent mines for each cell\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      const cell = board[i][j];\n\n      // Skip mines\n      if (isMine(cell)) continue;\n\n      // Count mines in neighboring cells\n      let count = 0;\n      traverseNeighbors(board, cell, neighbor => {\n        if (isMine(neighbor)) {\n          count++;\n        }\n      });\n      cell.bombs = count;\n    }\n  }\n}\nfunction openCell(game, field) {\n  if (field.isFlagged || field.isOpened) return game;\n\n  // Handle first click - ensure it's safe\n  if (isFirstClick) {\n    isFirstClick = false;\n\n    // If clicked on a mine, or has adjacent mines, regenerate the board\n    if (isMine(field) || field.bombs > 0) {\n      const rows = game.state.length;\n      const cols = game.state[0].length;\n\n      // Create a new board with the safe area\n      const newBoard = fillBoard(rows, cols, game.totBombs, field.pos);\n\n      // Update game with new board\n      game = new Game(newBoard, false, game.totBombs);\n\n      // Get the corresponding cell in the new board\n      field = game.state[field.pos.x][field.pos.y];\n    }\n  }\n  const newState = createDeepCopy(game.state);\n  const clickedCell = newState[field.pos.x][field.pos.y];\n\n  // If mine, game over\n  if (isMine(clickedCell)) {\n    revealAllMines(newState);\n    return new Game(newState, true, game.totBombs);\n  }\n\n  // Open the cell\n  clickedCell.isOpened = true;\n\n  // If empty, open surrounding cells\n  if (clickedCell.bombs === 0) {\n    openEmptyCells(newState, clickedCell);\n  }\n  return new Game(newState, false, game.totBombs);\n}\nfunction openEmptyCells(board, startCell) {\n  const visited = new Set();\n  const queue = [startCell];\n  while (queue.length > 0) {\n    const cell = queue.shift();\n    const key = `${cell.pos.x},${cell.pos.y}`;\n    if (visited.has(key)) continue;\n    visited.add(key);\n    cell.isOpened = true;\n\n    // If cell has no adjacent mines, explore neighbors\n    if (cell.bombs === 0) {\n      traverseNeighbors(board, cell, neighbor => {\n        if (!neighbor.isOpened && !neighbor.isFlagged && !isMine(neighbor)) {\n          queue.push(neighbor);\n        }\n      });\n    }\n  }\n}\nfunction toggleFlag(game, field) {\n  if (field.isOpened) return game;\n  const newState = createDeepCopy(game.state);\n  const cell = newState[field.pos.x][field.pos.y];\n  cell.isFlagged = !cell.isFlagged;\n  return new Game(newState, game.isOver, game.totBombs);\n}\nfunction checkCompleted(game) {\n  for (let i = 0; i < game.state.length; i++) {\n    for (let j = 0; j < game.state[i].length; j++) {\n      const cell = game.state[i][j];\n\n      // If a non-mine cell is not opened, game is not complete\n      if (!isMine(cell) && !cell.isOpened) {\n        return false;\n      }\n\n      // If a mine is not flagged, game is not complete\n      if (isMine(cell) && !cell.isFlagged) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction countFlagged(game) {\n  let count = 0;\n  for (let i = 0; i < game.state.length; i++) {\n    for (let j = 0; j < game.state[i].length; j++) {\n      if (game.state[i][j].isFlagged) {\n        count++;\n      }\n    }\n  }\n  return count;\n}\nfunction revealAllMines(board) {\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      if (isMine(board[i][j])) {\n        board[i][j].isOpened = true;\n      }\n    }\n  }\n}\nfunction createDeepCopy(state) {\n  return state.map(row => row.map(cell => new Mine({\n    x: cell.pos.x,\n    y: cell.pos.y\n  }, cell.bombs, cell.isFlagged, cell.isOpened)));\n}\nexport const game = {\n  newGame,\n  fillBombsCount,\n  countFlagged,\n  isCompleted: checkCompleted,\n  markMine: toggleFlag,\n  openMine: openCell\n};","map":{"version":3,"names":["Game","Mine","MINE","dx","dy","isFirstClick","isMine","mine","bombs","traverseNeighbors","board","callback","x","y","pos","i","length","newX","newY","fillBoard","rows","cols","mines","safePos","row","j","push","minesPlaced","Math","floor","random","abs","fillBombsCount","newGame","cell","count","neighbor","openCell","game","field","isFlagged","isOpened","state","newBoard","totBombs","newState","createDeepCopy","clickedCell","revealAllMines","openEmptyCells","startCell","visited","Set","queue","shift","key","has","add","toggleFlag","isOver","checkCompleted","countFlagged","map","isCompleted","markMine","openMine"],"sources":["/Users/laurakushnir/Documents/Minesweeper-TS/minesweeper-1/src/gameLogic/game.ts"],"sourcesContent":["import { Game, Mine, Point } from './gameDomain';\n\nconst MINE = -1;\nconst dx = [-1, 0, 1, -1, 1, -1, 0, 1];\nconst dy = [-1, -1, -1, 0, 0, 1, 1, 1];\n\n// Track if this is the first click of the game\nlet isFirstClick = true;\n\n// Helper functions\nfunction isMine(mine: Mine): boolean {\n    return mine.bombs === MINE;\n}\n\nfunction traverseNeighbors(board: Mine[][], mine: Mine, callback: (field: Mine) => void): void {\n    const { x, y } = mine.pos;\n    \n    for (let i = 0; i < dx.length; i++) {\n        const newX = x + dx[i];\n        const newY = y + dy[i];\n        \n        // Check if coordinates are within bounds\n        if (newX >= 0 && newX < board.length && newY >= 0 && newY < board[0].length) {\n            callback(board[newX][newY]);\n        }\n    }\n}\n\nfunction fillBoard(rows: number, cols: number, mines: number, safePos?: Point): Array<Array<Mine>> {\n    const board: Mine[][] = [];\n\n    // Initialize a board with no mines\n    for(let i = 0; i < rows; i++){\n        const row: Mine[] = [];\n        for(let j = 0; j < cols; j++){\n            row.push(new Mine({x: i, y: j}, 0, false, false));\n        }\n        board.push(row);\n    }\n\n    // Place mines randomly on the board\n    let minesPlaced = 0;\n    while (minesPlaced < mines) {\n        let x = Math.floor(Math.random() * rows);\n        let y = Math.floor(Math.random() * cols);\n\n        // Skip if mine is already placed at this position\n        if (isMine(board[x][y])) {\n            continue;\n        }\n        \n        // Skip if this is within the safe area around the first click\n        if (safePos && Math.abs(x - safePos.x) <= 1 && Math.abs(y - safePos.y) <= 1) {\n            continue;\n        }\n\n        board[x][y].bombs = MINE;\n        minesPlaced++;\n    }\n    \n    // Calculate numbers for each cell\n    fillBombsCount(board);\n    \n    return board;\n}\n\nfunction newGame(rows: number, cols: number, mines: number): Game {\n    // Reset first click tracking for a new game\n    isFirstClick = true;\n    \n    const board = fillBoard(rows, cols, mines);\n    return new Game(board, false, mines);\n}\n\nfunction fillBombsCount(board: Array<Array<Mine>>): void {\n    // First, reset all non-mine cells to zero\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (!isMine(board[i][j])) {\n                board[i][j].bombs = 0;\n            }\n        }\n    }\n    \n    // Then count adjacent mines for each cell\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            const cell = board[i][j];\n            \n            // Skip mines\n            if (isMine(cell)) continue;\n            \n            // Count mines in neighboring cells\n            let count = 0;\n            traverseNeighbors(board, cell, (neighbor) => {\n                if (isMine(neighbor)) {\n                    count++;\n                }\n            });\n            \n            cell.bombs = count;\n        }\n    }\n}\n\nfunction openCell(game: Game, field: Mine): Game {\n    if (field.isFlagged || field.isOpened) return game;\n    \n    // Handle first click - ensure it's safe\n    if (isFirstClick) {\n        isFirstClick = false;\n        \n        // If clicked on a mine, or has adjacent mines, regenerate the board\n        if (isMine(field) || field.bombs > 0) {\n            const rows = game.state.length;\n            const cols = game.state[0].length;\n            \n            // Create a new board with the safe area\n            const newBoard = fillBoard(rows, cols, game.totBombs, field.pos);\n            \n            // Update game with new board\n            game = new Game(newBoard, false, game.totBombs);\n            \n            // Get the corresponding cell in the new board\n            field = game.state[field.pos.x][field.pos.y];\n        }\n    }\n    \n    const newState = createDeepCopy(game.state);\n    const clickedCell = newState[field.pos.x][field.pos.y];\n    \n    // If mine, game over\n    if (isMine(clickedCell)) {\n        revealAllMines(newState);\n        return new Game(newState, true, game.totBombs);\n    }\n    \n    // Open the cell\n    clickedCell.isOpened = true;\n    \n    // If empty, open surrounding cells\n    if (clickedCell.bombs === 0) {\n        openEmptyCells(newState, clickedCell);\n    }\n    \n    return new Game(newState, false, game.totBombs);\n}\n\nfunction openEmptyCells(board: Array<Array<Mine>>, startCell: Mine): void {\n    const visited = new Set<string>();\n    const queue: Mine[] = [startCell];\n    \n    while (queue.length > 0) {\n        const cell = queue.shift()!;\n        const key = `${cell.pos.x},${cell.pos.y}`;\n        \n        if (visited.has(key)) continue;\n        visited.add(key);\n        \n        cell.isOpened = true;\n        \n        // If cell has no adjacent mines, explore neighbors\n        if (cell.bombs === 0) {\n            traverseNeighbors(board, cell, (neighbor) => {\n                if (!neighbor.isOpened && !neighbor.isFlagged && !isMine(neighbor)) {\n                    queue.push(neighbor);\n                }\n            });\n        }\n    }\n}\n\nfunction toggleFlag(game: Game, field: Mine): Game {\n    if (field.isOpened) return game;\n    \n    const newState = createDeepCopy(game.state);\n    const cell = newState[field.pos.x][field.pos.y];\n    cell.isFlagged = !cell.isFlagged;\n    \n    return new Game(newState, game.isOver, game.totBombs);\n}\n\nfunction checkCompleted(game: Game): boolean {\n    for (let i = 0; i < game.state.length; i++) {\n        for (let j = 0; j < game.state[i].length; j++) {\n            const cell = game.state[i][j];\n            \n            // If a non-mine cell is not opened, game is not complete\n            if (!isMine(cell) && !cell.isOpened) {\n                return false;\n            }\n            \n            // If a mine is not flagged, game is not complete\n            if (isMine(cell) && !cell.isFlagged) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nfunction countFlagged(game: Game): number {\n    let count = 0;\n    \n    for (let i = 0; i < game.state.length; i++) {\n        for (let j = 0; j < game.state[i].length; j++) {\n            if (game.state[i][j].isFlagged) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n\nfunction revealAllMines(board: Array<Array<Mine>>): void {\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (isMine(board[i][j])) {\n                board[i][j].isOpened = true;\n            }\n        }\n    }\n}\n\nfunction createDeepCopy(state: Array<Array<Mine>>): Array<Array<Mine>> {\n    return state.map(row => \n        row.map(cell => \n            new Mine(\n                { x: cell.pos.x, y: cell.pos.y },\n                cell.bombs,\n                cell.isFlagged,\n                cell.isOpened\n            )\n        )\n    );\n}\n\nexport const game = {\n    newGame,\n    fillBombsCount,\n    countFlagged,\n    isCompleted: checkCompleted,\n    markMine: toggleFlag,\n    openMine: openCell\n};"],"mappings":"AAAA,SAASA,IAAI,EAAEC,IAAI,QAAe,cAAc;AAEhD,MAAMC,IAAI,GAAG,CAAC,CAAC;AACf,MAAMC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AACtC,MAAMC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;AAEtC;AACA,IAAIC,YAAY,GAAG,IAAI;;AAEvB;AACA,SAASC,MAAMA,CAACC,IAAU,EAAW;EACjC,OAAOA,IAAI,CAACC,KAAK,KAAKN,IAAI;AAC9B;AAEA,SAASO,iBAAiBA,CAACC,KAAe,EAAEH,IAAU,EAAEI,QAA+B,EAAQ;EAC3F,MAAM;IAAEC,CAAC;IAAEC;EAAE,CAAC,GAAGN,IAAI,CAACO,GAAG;EAEzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,EAAE,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;IAChC,MAAME,IAAI,GAAGL,CAAC,GAAGT,EAAE,CAACY,CAAC,CAAC;IACtB,MAAMG,IAAI,GAAGL,CAAC,GAAGT,EAAE,CAACW,CAAC,CAAC;;IAEtB;IACA,IAAIE,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAGP,KAAK,CAACM,MAAM,IAAIE,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAGR,KAAK,CAAC,CAAC,CAAC,CAACM,MAAM,EAAE;MACzEL,QAAQ,CAACD,KAAK,CAACO,IAAI,CAAC,CAACC,IAAI,CAAC,CAAC;IAC/B;EACJ;AACJ;AAEA,SAASC,SAASA,CAACC,IAAY,EAAEC,IAAY,EAAEC,KAAa,EAAEC,OAAe,EAAsB;EAC/F,MAAMb,KAAe,GAAG,EAAE;;EAE1B;EACA,KAAI,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,IAAI,EAAEL,CAAC,EAAE,EAAC;IACzB,MAAMS,GAAW,GAAG,EAAE;IACtB,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,EAAEI,CAAC,EAAE,EAAC;MACzBD,GAAG,CAACE,IAAI,CAAC,IAAIzB,IAAI,CAAC;QAACW,CAAC,EAAEG,CAAC;QAAEF,CAAC,EAAEY;MAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IACrD;IACAf,KAAK,CAACgB,IAAI,CAACF,GAAG,CAAC;EACnB;;EAEA;EACA,IAAIG,WAAW,GAAG,CAAC;EACnB,OAAOA,WAAW,GAAGL,KAAK,EAAE;IACxB,IAAIV,CAAC,GAAGgB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGV,IAAI,CAAC;IACxC,IAAIP,CAAC,GAAGe,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGT,IAAI,CAAC;;IAExC;IACA,IAAIf,MAAM,CAACI,KAAK,CAACE,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC,EAAE;MACrB;IACJ;;IAEA;IACA,IAAIU,OAAO,IAAIK,IAAI,CAACG,GAAG,CAACnB,CAAC,GAAGW,OAAO,CAACX,CAAC,CAAC,IAAI,CAAC,IAAIgB,IAAI,CAACG,GAAG,CAAClB,CAAC,GAAGU,OAAO,CAACV,CAAC,CAAC,IAAI,CAAC,EAAE;MACzE;IACJ;IAEAH,KAAK,CAACE,CAAC,CAAC,CAACC,CAAC,CAAC,CAACL,KAAK,GAAGN,IAAI;IACxByB,WAAW,EAAE;EACjB;;EAEA;EACAK,cAAc,CAACtB,KAAK,CAAC;EAErB,OAAOA,KAAK;AAChB;AAEA,SAASuB,OAAOA,CAACb,IAAY,EAAEC,IAAY,EAAEC,KAAa,EAAQ;EAC9D;EACAjB,YAAY,GAAG,IAAI;EAEnB,MAAMK,KAAK,GAAGS,SAAS,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,CAAC;EAC1C,OAAO,IAAItB,IAAI,CAACU,KAAK,EAAE,KAAK,EAAEY,KAAK,CAAC;AACxC;AAEA,SAASU,cAAcA,CAACtB,KAAyB,EAAQ;EACrD;EACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,KAAK,CAACK,CAAC,CAAC,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;MACtC,IAAI,CAACnB,MAAM,CAACI,KAAK,CAACK,CAAC,CAAC,CAACU,CAAC,CAAC,CAAC,EAAE;QACtBf,KAAK,CAACK,CAAC,CAAC,CAACU,CAAC,CAAC,CAACjB,KAAK,GAAG,CAAC;MACzB;IACJ;EACJ;;EAEA;EACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,KAAK,CAACK,CAAC,CAAC,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;MACtC,MAAMS,IAAI,GAAGxB,KAAK,CAACK,CAAC,CAAC,CAACU,CAAC,CAAC;;MAExB;MACA,IAAInB,MAAM,CAAC4B,IAAI,CAAC,EAAE;;MAElB;MACA,IAAIC,KAAK,GAAG,CAAC;MACb1B,iBAAiB,CAACC,KAAK,EAAEwB,IAAI,EAAGE,QAAQ,IAAK;QACzC,IAAI9B,MAAM,CAAC8B,QAAQ,CAAC,EAAE;UAClBD,KAAK,EAAE;QACX;MACJ,CAAC,CAAC;MAEFD,IAAI,CAAC1B,KAAK,GAAG2B,KAAK;IACtB;EACJ;AACJ;AAEA,SAASE,QAAQA,CAACC,IAAU,EAAEC,KAAW,EAAQ;EAC7C,IAAIA,KAAK,CAACC,SAAS,IAAID,KAAK,CAACE,QAAQ,EAAE,OAAOH,IAAI;;EAElD;EACA,IAAIjC,YAAY,EAAE;IACdA,YAAY,GAAG,KAAK;;IAEpB;IACA,IAAIC,MAAM,CAACiC,KAAK,CAAC,IAAIA,KAAK,CAAC/B,KAAK,GAAG,CAAC,EAAE;MAClC,MAAMY,IAAI,GAAGkB,IAAI,CAACI,KAAK,CAAC1B,MAAM;MAC9B,MAAMK,IAAI,GAAGiB,IAAI,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC1B,MAAM;;MAEjC;MACA,MAAM2B,QAAQ,GAAGxB,SAAS,CAACC,IAAI,EAAEC,IAAI,EAAEiB,IAAI,CAACM,QAAQ,EAAEL,KAAK,CAACzB,GAAG,CAAC;;MAEhE;MACAwB,IAAI,GAAG,IAAItC,IAAI,CAAC2C,QAAQ,EAAE,KAAK,EAAEL,IAAI,CAACM,QAAQ,CAAC;;MAE/C;MACAL,KAAK,GAAGD,IAAI,CAACI,KAAK,CAACH,KAAK,CAACzB,GAAG,CAACF,CAAC,CAAC,CAAC2B,KAAK,CAACzB,GAAG,CAACD,CAAC,CAAC;IAChD;EACJ;EAEA,MAAMgC,QAAQ,GAAGC,cAAc,CAACR,IAAI,CAACI,KAAK,CAAC;EAC3C,MAAMK,WAAW,GAAGF,QAAQ,CAACN,KAAK,CAACzB,GAAG,CAACF,CAAC,CAAC,CAAC2B,KAAK,CAACzB,GAAG,CAACD,CAAC,CAAC;;EAEtD;EACA,IAAIP,MAAM,CAACyC,WAAW,CAAC,EAAE;IACrBC,cAAc,CAACH,QAAQ,CAAC;IACxB,OAAO,IAAI7C,IAAI,CAAC6C,QAAQ,EAAE,IAAI,EAAEP,IAAI,CAACM,QAAQ,CAAC;EAClD;;EAEA;EACAG,WAAW,CAACN,QAAQ,GAAG,IAAI;;EAE3B;EACA,IAAIM,WAAW,CAACvC,KAAK,KAAK,CAAC,EAAE;IACzByC,cAAc,CAACJ,QAAQ,EAAEE,WAAW,CAAC;EACzC;EAEA,OAAO,IAAI/C,IAAI,CAAC6C,QAAQ,EAAE,KAAK,EAAEP,IAAI,CAACM,QAAQ,CAAC;AACnD;AAEA,SAASK,cAAcA,CAACvC,KAAyB,EAAEwC,SAAe,EAAQ;EACtE,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAS,CAAC;EACjC,MAAMC,KAAa,GAAG,CAACH,SAAS,CAAC;EAEjC,OAAOG,KAAK,CAACrC,MAAM,GAAG,CAAC,EAAE;IACrB,MAAMkB,IAAI,GAAGmB,KAAK,CAACC,KAAK,CAAC,CAAE;IAC3B,MAAMC,GAAG,GAAG,GAAGrB,IAAI,CAACpB,GAAG,CAACF,CAAC,IAAIsB,IAAI,CAACpB,GAAG,CAACD,CAAC,EAAE;IAEzC,IAAIsC,OAAO,CAACK,GAAG,CAACD,GAAG,CAAC,EAAE;IACtBJ,OAAO,CAACM,GAAG,CAACF,GAAG,CAAC;IAEhBrB,IAAI,CAACO,QAAQ,GAAG,IAAI;;IAEpB;IACA,IAAIP,IAAI,CAAC1B,KAAK,KAAK,CAAC,EAAE;MAClBC,iBAAiB,CAACC,KAAK,EAAEwB,IAAI,EAAGE,QAAQ,IAAK;QACzC,IAAI,CAACA,QAAQ,CAACK,QAAQ,IAAI,CAACL,QAAQ,CAACI,SAAS,IAAI,CAAClC,MAAM,CAAC8B,QAAQ,CAAC,EAAE;UAChEiB,KAAK,CAAC3B,IAAI,CAACU,QAAQ,CAAC;QACxB;MACJ,CAAC,CAAC;IACN;EACJ;AACJ;AAEA,SAASsB,UAAUA,CAACpB,IAAU,EAAEC,KAAW,EAAQ;EAC/C,IAAIA,KAAK,CAACE,QAAQ,EAAE,OAAOH,IAAI;EAE/B,MAAMO,QAAQ,GAAGC,cAAc,CAACR,IAAI,CAACI,KAAK,CAAC;EAC3C,MAAMR,IAAI,GAAGW,QAAQ,CAACN,KAAK,CAACzB,GAAG,CAACF,CAAC,CAAC,CAAC2B,KAAK,CAACzB,GAAG,CAACD,CAAC,CAAC;EAC/CqB,IAAI,CAACM,SAAS,GAAG,CAACN,IAAI,CAACM,SAAS;EAEhC,OAAO,IAAIxC,IAAI,CAAC6C,QAAQ,EAAEP,IAAI,CAACqB,MAAM,EAAErB,IAAI,CAACM,QAAQ,CAAC;AACzD;AAEA,SAASgB,cAAcA,CAACtB,IAAU,EAAW;EACzC,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuB,IAAI,CAACI,KAAK,CAAC1B,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACI,KAAK,CAAC3B,CAAC,CAAC,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;MAC3C,MAAMS,IAAI,GAAGI,IAAI,CAACI,KAAK,CAAC3B,CAAC,CAAC,CAACU,CAAC,CAAC;;MAE7B;MACA,IAAI,CAACnB,MAAM,CAAC4B,IAAI,CAAC,IAAI,CAACA,IAAI,CAACO,QAAQ,EAAE;QACjC,OAAO,KAAK;MAChB;;MAEA;MACA,IAAInC,MAAM,CAAC4B,IAAI,CAAC,IAAI,CAACA,IAAI,CAACM,SAAS,EAAE;QACjC,OAAO,KAAK;MAChB;IACJ;EACJ;EAEA,OAAO,IAAI;AACf;AAEA,SAASqB,YAAYA,CAACvB,IAAU,EAAU;EACtC,IAAIH,KAAK,GAAG,CAAC;EAEb,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuB,IAAI,CAACI,KAAK,CAAC1B,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACI,KAAK,CAAC3B,CAAC,CAAC,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;MAC3C,IAAIa,IAAI,CAACI,KAAK,CAAC3B,CAAC,CAAC,CAACU,CAAC,CAAC,CAACe,SAAS,EAAE;QAC5BL,KAAK,EAAE;MACX;IACJ;EACJ;EAEA,OAAOA,KAAK;AAChB;AAEA,SAASa,cAAcA,CAACtC,KAAyB,EAAQ;EACrD,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,KAAK,CAACK,CAAC,CAAC,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;MACtC,IAAInB,MAAM,CAACI,KAAK,CAACK,CAAC,CAAC,CAACU,CAAC,CAAC,CAAC,EAAE;QACrBf,KAAK,CAACK,CAAC,CAAC,CAACU,CAAC,CAAC,CAACgB,QAAQ,GAAG,IAAI;MAC/B;IACJ;EACJ;AACJ;AAEA,SAASK,cAAcA,CAACJ,KAAyB,EAAsB;EACnE,OAAOA,KAAK,CAACoB,GAAG,CAACtC,GAAG,IAChBA,GAAG,CAACsC,GAAG,CAAC5B,IAAI,IACR,IAAIjC,IAAI,CACJ;IAAEW,CAAC,EAAEsB,IAAI,CAACpB,GAAG,CAACF,CAAC;IAAEC,CAAC,EAAEqB,IAAI,CAACpB,GAAG,CAACD;EAAE,CAAC,EAChCqB,IAAI,CAAC1B,KAAK,EACV0B,IAAI,CAACM,SAAS,EACdN,IAAI,CAACO,QACT,CACJ,CACJ,CAAC;AACL;AAEA,OAAO,MAAMH,IAAI,GAAG;EAChBL,OAAO;EACPD,cAAc;EACd6B,YAAY;EACZE,WAAW,EAAEH,cAAc;EAC3BI,QAAQ,EAAEN,UAAU;EACpBO,QAAQ,EAAE5B;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}